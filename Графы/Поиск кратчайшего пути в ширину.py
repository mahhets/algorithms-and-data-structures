"""
Поиск кратчайшего пути в ширину(Breadth-First Search)

!!! Оптимален только для НЕ взвешенных графов !!
Поиск в ширину работае путем последовательного просмотра отдельных уровней графа

1. Поместить вершину, с которой начинаем двигаться, в пустую очередь

2. Извлечь из начала очереди вершину, которая там находится:

    1. Если вершина является целевой - завершаем поиск(пришли в нужную точку)
    2. В противном случае в конец очереди добавляются все следующие вершины, которые
        еще не пройдены и не находятся в очереди

3. Если очередь оказывается пуста, то все вершины графа были просмотрены, следовательно,
    целевой узел недостежим из начального -> завершить поиск
"""
from collections import deque

graph = [
    [0,1,1,0,1,0,0,0],
    [1,0,0,0,0,0,0,0],
    [1,0,0,0,1,0,0,0],
    [0,0,0,0,0,1,0,0],
    [1,0,1,0,0,0,1,0],
    [0,0,0,1,0,0,1,1],
    [0,0,0,0,1,1,0,1],
    [0,0,0,0,0,1,1,0]
]

def bfs(graph, start, finish):
    parent = [None for _ in range(len(graph))] # Родитель для каждой вершины
    is_visited = [False for _ in range(len(graph))] # Если были в данной вершине, то будем ставить True и наоборот

    deq = deque([start])
    is_visited[start] = True # нам не нужно заходить в вершину старта повторно

    while len(deq) > 0:

        curent = deq.pop() # Первый шаг

        if curent == finish: # 2.1 Если данная вершина являтеся концом
            #return parent
            break

        for i, vertex in enumerate(graph[curent]): # 2.2
            if vertex == 1 and not is_visited[i]:

                is_visited[i] = True # отмечаем вершину как посещенную
                parent[i] = curent # из какой вершины мы пришли
                deq.appendleft(i)

    else:
        return f'Из вершины {start} нельзя попасть в вершину'

    cost = 0 # стоимость пути
    way = deque([finish]) # Добавим в очередь значение целевой вершины
    i = finish # Сохраним это значение

    while parent[i] != start: # Пока не дошли до первой вершины
        cost +=1
        way.appendleft(parent[i]) # добавляем в начало очереди родительскую вершину
        i = parent[i] # поместим в i родительскую вершину

    cost +=1 # Когда дошли до начала - увеличим стоимость еще на 1, поскольку для попадания в эту вершину нужно заплатить
    way.appendleft(start) # Добавим в начало очереди первую вершину

    return f'Кратчайший путь {list(way)} длинной в {cost} у.е.'

s = int(input('От какой вершины идти: '))
f = int(input('До какой вершины идти: '))
print(bfs(graph,s,f))
