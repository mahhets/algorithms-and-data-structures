"""
Поиск кратчайшего пути по алгоритму Дейкстры
(Нахождение кратчайшего пути от одной из вершин графа до всех остальных)
!!! Отлично ищет путь на взвешенном орграфе!!! ВЕС РЕБРА ДОЛЖЕН БЫТЬ ПОЛОЖИТЕЛЬНЫЙ!!!
"""

graph = [
    [0,0,1,1,9,0,0,0],
    [0,0,9,4,0,0,5,0],
    [0,9,0,0,3,0,6,0],
    [0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,5,0],
    [0,0,7,0,8,1,0,0],
    [0,0,0,0,0,1,2,0]
]

def dijkstra(graph, start):
    length = len(graph)
    is_visited = [False] * length # В этом списке будем хранить данные о посещении вершины
    cost = [float('inf')] * length # Стоимость пути для конкретной вершины, изначально мы не знаем, поэтому inf
    parent = [-1] * length # Пока мы не знаем родителя, в списке будет храниться -1

    cost[start] = 0 # Путь до вершины, в которой мы находимся
    min_cost = 0 # Изначальная минимальня стоимость

    while min_cost < float('inf'):

        is_visited[start] = True # Отметим стартовую вершину посещенной
        """
        1.Обходим все вмежные вершины и записываем минимальные расстояния для них
        """
        for i, vertex in enumerate(graph[start]):
            if vertex !=0 and not is_visited[i]:

                if cost[i] > vertex + cost[start]: # Если расстояние для вершины больше, чем сумма от старта до i
                    cost[i] = vertex + cost[start] # Записываем новое, более короткое расстояние
                    parent[i] = start # Записываем, какая вершина является родительской

        """
        2.
        """
        min_cost = float('inf') # Изменяем значение минимального пути на бесконечность
        for i in range(length): # Цикл по всем вершина графа
            if min_cost > cost[i] and not is_visited[i]: # min больше стоимости пути и вершину не посещали
                min_cost = cost[i] # сохранили минимальное расстояние
                start = i # нахначили эту вершину стартовой

    return cost


s = int(input('От какой вершины идти: '))
print(dijkstra(graph, s))

