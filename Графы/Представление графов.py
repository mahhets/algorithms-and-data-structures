"""
1. Матрица смежности
2. Списки смежности
3. Списки ребер
"""

# 1.1 Представление простого графа в виде матрицы смежгости
"""
Вершина графа 0 соеднинена с 1 и 2
Вершина графа 1 соединена с 1, 2, 3
Вершина 2 соединена с 0, 1
Вершина 3 соединена с 1
"""
graph = [
    [0,1,1,0], # 0
    [1,0,1,1], # 1
    [1,1,0,0], # 2
    [0,0,0,1]  # 3
]

print(*graph, sep='\n')

# 1.2 Ориентированный граф
"""
Не нулевое значение означает, что от одной вершины есть указатель к другой вершине
К примеру наша 1 вершина больше не связан с 0, но при этом 0 связан с 1, т.к. ориентированный граф направлен от 0 -> 1

Если же у линий смежности есть веса, то в нашем случае единицыв необходимо заменить на значения весов

При хранении графов в матрице смежности, мы будем тратить W**2 памяти, где W это кол-во вершин в графе
"""

graph = [
    [0,1,1,0], # 0
    [0,0,1,1], # 1
    [0,1,0,0], # 2
    [0,0,0,0]  # 3
]
print(*graph, sep='\n')
print('*'*50)
graph[0][1:3] = [2,3]
graph[1][2] = 2
graph[2][1] = 2
print(*graph, sep='\n')
print('-'*50)


# 2. Списки смежности
"""
Создается список для каждой вершины
В этом списке хранятся вершины, которые являются соседними
"""
print('Списки смежности')
graph = []

graph.append([1,2])
graph.append([0,2,3])
graph.append([0,1])
graph.append([1])
print(*graph, sep='\n')

# Граф на основе словаря и множества
print('Граф на основе словаря и множества')
graph_2 = {
    0:{1,2},
    1:{0,2,3},
    2:{0,1},
    3:{1},
}
print(graph_2)

# Проверка, что из вершины 1 мы можем попасть в вершину 3
if 3 in graph_2[1]:
    print('Из вершины 3 мы можем попасть в вершину 1')

# Взвешенный грай в списке смежности
print('Взвешенный грай в списке смежности')
from collections import namedtuple
Vertex = namedtuple('Vertex',['vertex','edge'])
graph_3 = []

graph_3.append([Vertex(1,2),Vertex(2,3)]) # Путь из 0 -> 1 стоит 2 единицы, путь 0 -> 2 стоит 3 единицы
graph_3.append([Vertex(0,2), Vertex(2,2), Vertex(3,1)])
graph_3.append([Vertex(0,3), Vertex(1,2)])
graph_3.append([Vertex(1,1)])

print(*graph_3, sep='\n')

# Проверка, что из вершины 1 можно попасть в вершину 3
for v in graph_3[1]:
# Если очередной элемент v из первой строки будет иметь 3 в качестве вершины, значит такой путь возможен
    if v.vertex == 3:
        print('это возможно')

# Хранение графов в виде класса
class Graph:
    def __init__(self, vertex, edge, spam):
        self.vertex = vertex
        self.edge = edge
        self.spam = spam # дополнительная информация о вершинах(если нужна)

    # Далее нужно создать методы для работы с классами

# 3. Список ребер
"""
Данный способ заключается в том, что мы храним пары значений 
(вершина из которой выходит ребро, вершина в которую заходит)
Если граф оказывается взвешенным, то логично добавить 3 элемент - вес ребра
(1,2,3)  из вершины 1 в вершину 2 с весом 3
"""
print('Список ребер')
graph = [(0,1),(0,2),(1,2),(2,1),(1,3)]
print(*graph, sep='\n')